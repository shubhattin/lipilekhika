use std::collections::HashMap;
use std::sync::OnceLock;

use super::ScriptData;
use super::generated;

/// currently for simplicity using a single cache for all script data
static SCRIPT_DATA_CACHE: OnceLock<HashMap<String, ScriptData>> = OnceLock::new();
impl ScriptData {
  fn load_all() -> HashMap<String, ScriptData> {
    let mut map = HashMap::new();

    for &script_name in generated::SCRIPT_DATA_NAMES {
      let bytes = generated::get_script_data_bytes(script_name)
        .unwrap_or_else(|| panic!("Generated bytes missing for script `{}`", script_name));

      let data: ScriptData = bincode::deserialize(bytes)
        .unwrap_or_else(|e| panic!("bincode decode failed for script `{}`: {}", script_name, e));

      map.insert(script_name.to_string(), data);
    }

    map
  }

  /// this method assumes that the script name is already normalized,
  /// if not then it will panic.
  ///
  /// Normalize script before calling this
  pub fn get_script_data(script: &str) -> &'static ScriptData {
    let cache = SCRIPT_DATA_CACHE.get_or_init(Self::load_all);

    cache
      .get(script)
      .unwrap_or_else(|| panic!("Script `{}` not found", script))
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::fs;
  use std::path::Path;

  #[test]
  fn all_script_data_json_files_must_parse() {
    let dir = Path::new("src/data/script_data");

    let entries = fs::read_dir(dir).expect("Failed to read script_data directory");

    for entry in entries {
      let entry = entry.expect("Failed to read directory entry");
      let path = entry.path();

      // Only test *.json files
      if path.extension().and_then(|e| e.to_str()) == Some("json") {
        let script_name = path
          .file_stem()
          .and_then(|s| s.to_str())
          .expect("Invalid filename");
        println!("{}", script_name);

        let _ = ScriptData::get_script_data(script_name);
      }
    }
  }
}
