---
title: Rust
description: Lipi Lekhika usage in Rust
sidebar:
  order: 4
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { LinkCard } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

Lipi Lekhika offers a high-performance, type-safe transliteration library for Rust. All script data is embedded at compile time for zero runtime overhead.

## Installation

The recommended way to install is using `cargo add`:

```bash
cargo add lipilekhika
```

## Basic Usage

### Transliteration

The `transliterate` function is the primary API for converting text between scripts. It returns a `Result<String, String>`.

```rust
use lipilekhika::transliterate;

fn main() {
    let result = transliterate(
        "na jAyatE mriyatE vA",
        "Normal",
        "Devanagari",
        None
    ).unwrap();
    
    println!("{}", result); // न जायते म्रियते वा
}
```

**Parameters:**
- `text: &str` — Text to transliterate
- `from: &str` — Source script/language name
- `to: &str` — Target script/language name  
- `trans_options: Option<&HashMap<String, bool>>` — Optional custom transliteration options

**Returns:** `Result<String, String>` — Transliterated text or error message

### With Custom Transliteration Options

You can pass custom options as the fourth argument to fine-tune transliteration behavior:

```rust
use lipilekhika::transliterate;
use std::collections::HashMap;

fn main() {
    let mut options = HashMap::new();
    options.insert(
        "brahmic_to_brahmic:replace_pancham_varga_varna_with_anusvAra".to_string(),
        true
    );
    
    let result = transliterate(
        "గంగా",
        "Telugu",
        "Gujarati",
        Some(&options)
    ).unwrap();
    
    println!("{}", result); // ગંગા (instead of ગઙ્ગા)
}
```

<LinkCard 
   title="Custom Transliteration Options" 
   href="/reference/custom_trans_options" 
   description="A detailed overview of all available custom transliteration options"
/>
<LinkCard 
   title="Supported Scripts and Languages"
   href="/reference/supported_scripts"
   description="List of all supported scripts/languages and their aliases"
/>

## Utility Functions

### Getting Available Options

Use `get_all_option` to discover which custom options are available for a specific script pair:

```rust
use lipilekhika::get_all_option;

fn main() {
    let options = get_all_option("Devanagari", "Telugu").unwrap();
    
    for option in options {
        println!("Available option: {}", option);
    }
}
```

**Parameters:**
- `from_script_name: &str` — Source script/language name
- `to_script_name: &str` — Target script/language name

**Returns:** `Result<Vec<String>, String>` — List of option keys or error message

### Getting Script List Data

Use `get_script_list_data()` to grab the cached script metadata that powers the transliteration helpers.
It returns a `&'static ScriptListData` containing the ordered script and language names plus the maps that translate between languages, scripts, and alternate aliases.

```rust
use lipilekhika::get_script_list_data;

fn main() {
    let data = get_script_list_data();
    println!("Supported scripts: {:?}", data.scripts);
    println!("Language to script map: {:?}", data.lang_script_map);
}
```

Each call is zero-cost after the first because the data is stored in a `OnceLock`, so you can use it wherever you need to inspect available scripts or resolve language aliases.

### Getting Typing Data

Use `get_script_typing_data_map` to get typing mappings for a script (useful for building custom input methods):

```rust
use lipilekhika::get_script_typing_data_map;

fn main() {
    let typing_data = get_script_typing_data_map("Devanagari").unwrap();
    
    // Access common character mappings
    for (text, list_type, mappings) in &typing_data.common_krama_map {
        if !mappings.is_empty() {
            println!("{} can be typed using: {:?}", text, mappings);
        }
    }
    
    // Access script-specific character mappings
    for (text, list_type, mappings) in &typing_data.script_specific_krama_map {
        if !mappings.is_empty() {
            println!("{} (script-specific) can be typed using: {:?}", text, mappings);
        }
    }
}
```

**Parameters:**
- `script: &str` — Script/language name

**Returns:** `Result<ScriptTypingDataMap, String>` — Typing data containing:
- `common_krama_map` — Mappings for common characters
- `script_specific_krama_map` — Mappings for script-specific characters

Each mapping is a tuple of `(text: String, type: ListType, input_mappings: Vec<String>)`.

## Typing Module

For real-time character-by-character input, use the `typing` module which provides a stateful context for handling keyboard input.

### Basic Typing Context

```rust
use lipilekhika::typing::{TypingContext, TypingContextOptions};

fn main() {
    let mut ctx = TypingContext::new("Devanagari", None).unwrap();
    
    // Process character-by-character input
    let diff = ctx.take_key_input("n").unwrap();
    println!("Delete: {}, Add: '{}'", diff.to_delete_chars_count, diff.diff_add_text);
    // Output: Delete: 0, Add: 'न्'
    
    let diff = ctx.take_key_input("a").unwrap();
    println!("Delete: {}, Add: '{}'", diff.to_delete_chars_count, diff.diff_add_text);
    // Output: Delete: 2, Add: 'न'
    
    // Clear context when needed
    ctx.clear_context();
}
```

### With Custom Options

```rust
use lipilekhika::typing::{TypingContext, TypingContextOptions};

fn main() {
    let options = TypingContextOptions {
        auto_context_clear_time_ms: 3000,
        use_native_numerals: true,
        include_inherent_vowel: true, // For Hindi/Bengali style typing
    };
    
    let mut ctx = TypingContext::new("Devanagari", Some(options)).unwrap();
    
    let diff = ctx.take_key_input("k").unwrap();
    println!("{}", diff.diff_add_text); // क (with inherent vowel)
}
```

### Runtime Configuration

After creating a typing context, you can dynamically update typing options:
- **`ctx.update_use_native_numerals(bool)`** - Enable/disable native numerals (e.g., १० instead of 10)  
- **`ctx.update_include_inherent_vowel(bool)`** - Enable/disable inherent vowel inclusion (schwa deletion)  
- **`ctx.get_use_native_numerals()`** - Get current native numerals setting
- **`ctx.get_include_inherent_vowel()`** - Get current inherent vowel setting
- **`ctx.get_normalized_script()`** - Get current normalized script name  

### Typing Module Types

- **`TypingContext`** — Stateful context for typing mode
  - `new(typing_lang: &str, options: Option<TypingContextOptions>)` — Create new context
  - `take_key_input(&mut self, key: &str)` — Process single character input
  - `clear_context(&mut self)` — Clear internal state

- **`TypingContextOptions`** — Configuration for typing behavior
  - `auto_context_clear_time_ms: u64` — Auto-clear timeout (default: 4500ms)
  - `use_native_numerals: bool` — Use script-native numerals (default: true)
  - `include_inherent_vowel: bool` — Include inherent vowel/schwa (default: false)

- **`TypingDiff`** — Result of processing a key input
  - `to_delete_chars_count: usize` — Characters to delete from current state
  - `diff_add_text: String` — Text to insert

- **`ScriptTypingDataMap`** — Typing data for a script
  - `common_krama_map: Vec<TypingDataMapItem>` — Common character mappings
  - `script_specific_krama_map: Vec<TypingDataMapItem>` — Script-specific mappings

- **`ListType`** — Character type enum: `Anya`, `Vyanjana`, `Matra`, `Svara`

- **`TypingDataMapItem`** — Type alias for `(String, ListType, Vec<String>)`

## Performance Considerations

- **Embedded Data**: All script data is embedded at compile time using `rust-embed`, eliminating runtime file I/O
- **Static Lifetime**: Script data is cached with `'static` lifetime for zero-cost access
- **Zero Allocations**: The transliteration core minimizes allocations where possible
- **Type Safety**: Rust's type system prevents common runtime errors

## Error Handling

The library uses `Result<T, String>` for error handling. Common errors include:

- Invalid script/language names
- Unsupported script combinations (rare)

Always handle errors appropriately:

```rust
match transliterate("text", "InvalidScript", "Devanagari", None) {
    Ok(result) => println!("Success: {}", result),
    Err(e) => eprintln!("Error: {}", e),
}
```

## Additional Resources

<LinkCard 
   title="Crates.io Package" 
   href="https://crates.io/crates/lipilekhika"
   description="View package on crates.io"
/>
<LinkCard 
   title="GitHub Repository" 
   href="https://github.com/shubhattin/lipilekhika/tree/main/packages/rust"
   description="Source code and examples"
/>

## Next Steps

- Explore [custom transliteration options](/reference/custom_trans_options) for fine-tuned control
- Check out [supported scripts](/reference/supported_scripts) to see all available scripts
- Review [real-time typing reference](/reference/realtime_typing) for advanced typing implementations
